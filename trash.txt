______________________________ BLOCK OF TOKENS ______________________________

static t_list	*copy_tokens_block(t_list *curr_tkn, t_node *node_c)
{
// 	t_tkn_data	*tkn_content;
	t_tkn_data	*tkn_content_cpy;
	t_list		*tkn_node_cpy;
	t_list		*prev_tkn;

	tkn_node_cpy = NULL;
	tkn_content_cpy = NULL;
	prev_tkn = NULL;
	while (curr_tkn)
	{
		// !!!!  After distributing in each filed the tokens, block could be deleted....
				// tkn_content = (t_tkn_data *)curr_tkn->content;
		if (((t_tkn_data *)curr_tkn->content)->type == TKN_PIPE)
			return (curr_tkn);
				// tkn_content_cpy = cpy_tkn_content(tkn_content); // protect
				// tkn_node_cpy = ft_lstnew(tkn_content_cpy); // protect
				// if (!tkn_node_cpy)
				// 	return (NULL);
				// ft_lstadd_back(&((t_cmd *)node_c->content)->block, tkn_node_cpy);
		// !!!!  After distributing in each filed the tokens, block could be deleted....
		update_cmd_node(curr_tkn, prev_tkn, node_c);
		prev_tkn = curr_tkn;
		if (curr_tkn->next)
			curr_tkn = curr_tkn->next;
		else
			break ;
	}
	return (curr_tkn);
}


// static t_tkn_data	*cpy_tkn_content(t_tkn_data *content)
// {
// 	t_tkn_data	*cpy;

// 	cpy = ft_calloc(1, sizeof(t_tkn_data)); // prtct
// 	cpy->list_size = content->list_size;
// 	cpy->quote = content->quote;
// 	cpy->quote_status = content->quote_status;
// 	cpy->str = ft_strdup(content->str);
// 	cpy->type = content->type;
// 	cpy->white_space = content->white_space;
// 	return (cpy);
// }

add to struct
initialize into build_syntax tree
free_blok into free_tree
__________________________________________________________________________________________
